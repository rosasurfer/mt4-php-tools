#!/bin/bash
#
# Conveniant wrapper for Composer. Simplifies switching between multiple PHP and/or Composer versions.
#
# - The PHP interpreter can be configured by setting the environment variable PHP or editing config file "/.env".
# - The Composer executable can be configured by setting the environment variable PHPCOMPOSER or editing config file "/.env".
# - If environment variable DEBUG is set the script displays the final command to be executed.
# - If environment variable TRACE is set the script shows the location of the last error (if any).
#
# Examples:
#  PHP=php81 composer             Use a different PHP version instead of the standard `php`.
#
shopt -s inherit_errexit 2>/dev/null || :
set -eEuo pipefail


# --- functions ----------------------------------------------------------------------------------------------------------------------------


#
# Print a message to STDERR and exit the script/subshell.
#
# @param $@ - any number of arguments
#
function fail() {
  stderr "ERROR: $*"
  exit 127
}


#
# Print a message to STDERR but don't exit the script/subshell.
#
# @param $@ - any number of arguments
#
function stderr() {
  echo "$@" >&2
}


#
# Error handler. Shows the location of the last error if env variable TRACE is set to a non-zero value.
#
function onError() {
  local exitStatus=$? size=${#FUNCNAME[@]} i func file line

  if [[ "${TRACE:-0}" != "0" ]]; then
    stderr "ERROR: execution failed with status $exitStatus"
    for ((i=1; i < size; ++i)); do
      func="${FUNCNAME[i]}()                        "
      file="${BASH_SOURCE[i]}"
      line="${BASH_LINENO[i-1]}"
      ((i==1 && line==1)) && {
        [[ "$func" == 'fail()'* ]] && continue
        line='?'
      }
      stderr " in ${func:0:24} file: $file, line $line"
    done
  fi
  return "$exitStatus"
}
trap onError ERR


#
# Read configuration files in isolation and extract the requested variables.
#
# @param $1     - name of an indexed array with config files to read
# @param $2     - name of an associative array with the resulting configuration
# @param ${@:3} - any number of variable names to read from the config files
#
function readConfig() {
  local _files_="$1[@]" name value
  (("$#" < 3)) && fail "${FUNCNAME[0]}() missing arguments (min. 3)"
  [[ "$1" == '_files_' ]] && fail "${FUNCNAME[0]}() invalid argument \$1: illegal name '$1'"
  eval "((!\${#$_files_}))" && fail "${FUNCNAME[0]}() invalid argument \$1: empty"
  for name in "${@:3}"; do
    [[ "$name" == '_file_' || "$name" == '_name_' ]] && fail "${FUNCNAME[0]}() illegal argument name '$name'"
  done

  while IFS='=' read -r name value; do
    eval "$2[$name]='$value'"
  done < <(
    shift 2
    unset "$@"
    for _file_ in "${!_files_}"; do
      [[ -f "$_file_" ]] && source "$_file_" &> /dev/null
    done
    for _name_ in "$@"; do
      [[ -v "$_name_" ]] && echo "$_name_=${!_name_}"
    done
  )
}


#
# Finds a specified command in the PATH and makes sure it's not this script itself. Prints the found command.
#
# @param $1 - command
#
function findCommand() {
  local lines path
  readarray -t lines < <(type -ap "$1" 2>/dev/null || :)

  for path in "${lines[@]+"${lines[@]}"}"; do
    [[ "$(realpath "$path")" == "$self" ]] && continue
    [[ "$(stat -c '%d:%i' "$path")" == "$(stat -c '%d:%i' "$self")" ]] && continue
    echo "$path"
    return 0
  done
  return 1
}


# --- end of functions ---------------------------------------------------------------------------------------------------------------------


# ensure we run Bash v4.2+
((BASH_VERSINFO[0] < 4 || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 2))) && fail "this script requires Bash version 4.2+"


# resolve the project root directory
declare self projectDir
self="$(realpath "$(type -p "$0")")"
projectDir="$(realpath --relative-to=. "$(dirname "$self")"/..)"


# read the configuration
declare -a files=("$projectDir/.env.dist" "$projectDir/.env")
declare -A config=()
readConfig 'files' 'config' PHP PHPCOMPOSER

[[ -v PHP         ]] || PHP="${config[PHP]:-}"
[[ -v PHPCOMPOSER ]] || PHPCOMPOSER="${config[PHPCOMPOSER]:-}"


# determine the PHP interpreter to use
declare php="${PHP:-php}" isWindowsPhp
isWindowsPhp="$("$php" -r "echo (int)(PHP_OS_FAMILY == 'Windows');")"


# determine the Composer executable to use
declare composer composerCmd

if [[ -n "$PHPCOMPOSER" ]]; then                              # a user-specified command
  composerCmd="$PHPCOMPOSER"
  composer="$(findCommand "$PHPCOMPOSER")" || fail "Composer executable not found: $PHPCOMPOSER"
else
  composerCmd='composer' && composer="$(findCommand composer)" || {
    composerCmd='composer.phar' && composer="$(findCommand composer.phar)" || fail "Composer executable not found"
  }
fi
((isWindowsPhp)) && composer="$(cygpath -m "$composer")"


# on DEBUG: show the final command
if [[ "${DEBUG:-0}" != '0' ]]; then
  declare phpBin=''
  [[ "$php" != 'php' ]] && phpBin="$php "
  echo "CMD: ${phpBin}${composer} $*"
fi


# call Composer
"$php" "$composer" "$@" --ansi
